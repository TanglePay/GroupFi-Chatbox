<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Trollbox SDK Demo</title>
    <!-- <link
      rel="stylesheet"
      href="https://unpkg.com/groupfi-trollbox-sdk@1.0.14/dist/iife/assets/style.css"
    /> -->
    <link rel="stylesheet" href="./dist/iife/assets/style.css" />
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
      crossorigin="anonymous"
    />

    <!-- <script src="./demo_assets/third-party/tanglepay-sdk/tanglepay-common.js"></script>
    <script src="./demo_assets/third-party/tanglepay-sdk/index.js"></script> -->
    <!-- <script src="https://unpkg.com/groupfi-trollbox-sdk@1.0.14/dist/iife/index.js"></script> -->
    <script src="./dist/iife/index.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
      crossorigin="anonymous"
    ></script>
    <script
      defer
      src="https://c0f4f41c-2f55-4863-921b-sdk-docs.github.io/cdn/metamask-sdk.js"
    ></script>
    <!-- <script src="https://unpkg.com/vconsole@latest/dist/vconsole.min.js"></script>
    <script>
      var vConsole = new window.VConsole()
    </script> -->
    <style>
      .hidden {
        display: none;
      }
      body {
        padding-left: 10px;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: transparent;
        -webkit-text-size-adjust: none;
        -webkit-user-drag: none;
        user-select: none;
        touch-callout: none;
        tap-highlight-color: transparent;
        text-size-adjust: none;
        user-drag: none;
        max-width: 100%;
        min-width: 100%;
      }
    </style>
  </head>
  <body>
    <script>
      let isTrollboxReady = false
      // window.localStorage.clear()
      // const MMSDK = new MetaMaskSDK.MetaMaskSDK({
      //   dappMetadata: {
      //     name: 'Example Pure JS Dapp',
      //     url: window.location.href,
      //   },
      //   extensionOnly: true,
      //   // Other options.
      // });

      // setTimeout(() => {
      //   const provider = MMSDK.getProvider();
      //   trollbox.setWalletProvider(provider);
      //   window.provider = provider;
      // }, 0);

      const addEvent = () => {
        window.addEventListener('chatbox-ready', function () {
          isTrollboxReady = true
          console.log('üöÄ ~ isTrollboxReady:', isTrollboxReady)
          // ChatboxSDK.request({
          //   method: 'setGroups',
          //   params: {
          //     includes: [
          //       {
          //         groupId:
          //           'groupfiadmin7ef7bd5f49843d162c869edc56c59ef73e123a872563cdca1f612267696ae3df'
          //       },
          //       {
          //         groupId:
          //           'groupfiIOTAEVMcrabe333d8e9cbb9795276533bfaca266b931770474b7f31e077c826ef2a925acf55'
          //       },
          //       {
          //         groupId:
          //           'groupfiShimmerEVMcrab3d9a333ddfedd754b4757234310fa9b436e011846f57c40b33c503ee8cc50284'
          //       },
          //       {
          //         groupId:
          //           'groupfiGTESTcrab08181a9bbb45f85ce1399009e9bb0c9ad40d965cadd6db33b5b52e53d297998a'
          //       },
          //       {
          //         groupId:
          //           'groupfiSOLANA1crab24c2212ac62d865f937921070d7002113aed01d3271759339639bc0a1ed2518a'
          //       }
          //     ],
          //     announcement: [
          //       {
          //         groupId:
          //           'groupfiadmin7ef7bd5f49843d162c869edc56c59ef73e123a872563cdca1f612267696ae3df'
          //       }
          //     ]
          //   }
          // })

          document.getElementById('ready').innerText = true

          console.log('üöÄ ~ walletInfo:', walletInfo)
          if (walletInfo && walletInfo.type !== 'tanglpay') {
            ChatboxSDK.processAccount({
              account: walletInfo.address
            })
          }
          // ChatboxSDK.request({
          //   method: 'setGroups',
          //   params: {
          //     includes: [
          //       {
          //         groupId: `groupfiGroupfi'stestnftgroup441480db9942f0f2929dcaa365fe6f6a9362de4c5eb27daf0c1d9aaf21d198d9`
          //       },
          //       {
          //         groupid: 'groupfiGFTEST1fish0de70cefe0daf1ee0d431359a9c794a621c2d0a6a419f0726317d81e50557d24'
          //       },
          //       {
          //         groupId: 'groupfiGroupfiTestNFT2f7d754d6f9bd676435581567aa9ecc5d1bf402ada735192d111f15cb6e1e1751'
          //       }
          //     ]
          //   }
          // })
        })
      }

      addEvent()

      const storageKey = 'groupfi-wallet-info'

      function storeWalletInfo(walletInfo) {
        console.log('üöÄ ~ storeWalletInfo ~ walletInfo:', walletInfo)
        // localStorage.setItem(storageKey, JSON.stringify(walletInfo))
      }

      function clearWalletInfo() {
        localStorage.removeItem(storageKey)
      }

      function getWalletInfoFromStorage() {
        const walletInfoStr = window.localStorage.getItem(storageKey)
        console.log(
          'üöÄ ~ getWalletInfoFromStorage ~ walletInfoStr:',
          walletInfoStr
        )
        if (walletInfoStr) {
          return JSON.parse(walletInfoStr)
        }
        return null
      }

      let walletInfo = getWalletInfoFromStorage()

      window.onTPAccountsChanged = (data) => {
        const newAddress = data.address
        if (walletInfo && walletInfo.address === newAddress) {
          return
        }
        walletInfo = {
          type: 'tanglepay',
          address: newAddress
        }
        showWallInfo(walletInfo)
      }

      function showWallInfo(info) {
        const typeDom = document.getElementById('type')
        const addressDom = document.getElementById('address')

        typeDom.innerText = info?.type ?? ''
        addressDom.innerText = info?.address ?? ''

        if (info) {
          storeWalletInfo(info)
        } else {
          clearWalletInfo()
        }
      }

      const iotaEventKey = 'iota_event_accountsChanged'

      let isConnectingWallet = false

      function onSolanaAccountsChanged(provider) {
        return async (publicKey) => {
          if (publicKey) {
            const rawAccount = publicKey.toBase58()
            const account = rawAccount
            console.log('dapp solana account changes', account)

            walletInfo.address = account
          } else {
            const resp = await provider.request({ method: 'connect' })
            const rawAccount = resp.publicKey.toString()
            const account = rawAccount
            walletInfo.address = account
          }
          showWallInfo(walletInfo)
          if (isTrollboxReady) {
            ChatboxSDK.processAccount({
              account: walletInfo.address
            })
          }
        }
      }

      window.PhantomOnSolanaAccountsChanged = onSolanaAccountsChanged(
        window.phantom?.solana
      )

      function onMetaMaskAccountsChanged(accounts) {
        console.log('dapp metamask acounts changes', accounts)
        const account = accounts[0]

        // walletInfo = {
        //   type: walletInfo.type,
        //   address: account
        // }
        walletInfo.address = account

        showWallInfo(walletInfo)

        if (isTrollboxReady) {
          ChatboxSDK.processAccount({
            account: account
          })
        }
      }

      function clearEvents() {
        iota._events.removeAllListeners(iotaEventKey)
        // window.ethereum.removeAllListeners();
        if (window.metamaskProvider) {
          window.metamaskProvider.removeAllListeners()
        }

        if (window.okxwallet) {
          window.okxwallet.removeAllListeners()
        }

        if (window.phantom?.solana) {
          window.phantom?.solana.removeListener(
            'accountChanged',
            PhantomOnSolanaAccountsChanged
          )
        }
      }

      window.startBrowseMode = () => {
        const { theme, uiConfig } = generateRenderOptions()
        if (!isTrollboxReady) {
          ChatboxSDK.loadChatbox({
            isWalletConnected: false,
            theme: theme,
            uiConfig
          })
        } else {
          ChatboxSDK.processWallet({
            isWalletConnected: false
          })
        }
        walletInfo = null
        showWallInfo(walletInfo)
      }

      window.connectOKXWallet = async function () {
        if (isConnectingWallet) {
          return
        }
        if (walletInfo?.type === 'okx') {
          alert('Okx wallet has already been connected.')
          return
        }
        if (!window.okxwallet) {
          alert('OKX wallet is unintalled')
          return
        }
        if (isTrollboxReady) {
          clearEvents()
          ChatboxSDK.processWallet({
            isWalletConnected: true,
            provider: window.okxwallet
          })
        } else {
          const { theme, uiConfig } = generateRenderOptions()
          ChatboxSDK.loadChatbox({
            isWalletConnected: true,
            provider: window.okxwallet,
            theme,
            uiConfig
          })
        }
      }

      window.connectSolanaWallet = async function (provider, walletType) {
        if (isConnectingWallet) {
          return
        }
        if (walletInfo?.type === walletType) {
          alert(`${walletType} wallet has already been connected.`)
          return
        }
        if (typeof provider === undefined) {
          alert(`${walletType} is unintalled`)
          return
        }
        if (isTrollboxReady) {
          clearEvents()
          ChatboxSDK.processWallet({
            isWalletConnected: true,
            // provider: window.provider
            provider
          })
        }
        const connect = async () => {
          try {
            const resp = await provider.request({ method: 'connect' })
            const rawAccount = resp.publicKey.toString()

            if (!rawAccount) {
              throw new Error()
            }

            // Uniformly convert EVM addresses to lowercase
            // const account = rawAccount.toLowerCase()
            const account = rawAccount

            if (!isTrollboxReady) {
              const { theme, uiConfig } = generateRenderOptions()
              ChatboxSDK.loadChatbox({
                isWalletConnected: true,
                provider: provider,
                theme,
                uiConfig
              })
            }

            if (isTrollboxReady) {
              ChatboxSDK.processAccount({
                account: account
              })
            }

            walletInfo = {
              // type: 'metamask',
              type: walletType,
              address: account
            }

            showWallInfo(walletInfo)

            isConnectingWallet = false

            provider.on('accountChanged', PhantomOnSolanaAccountsChanged)
          } catch (err) {
            console.log(err)
          }
        }
        connect()
      }

      window.generateRenderOptions = () => {
        // theme
        const form = document.getElementById('themes')
        const themes = form.querySelectorAll(
          'input[type=radio][name=theme]:checked'
        )
        const theme = themes[0].value

        // accent
        const formAc = document.getElementById('accent_colors')
        const acs = formAc.querySelectorAll(
          'input[type=radio][name=ac]:checked'
        )
        const ac = acs[0].value

        // title
        const title = document.getElementById('title').value

        // subTitle
        const subTitle = document.getElementById('subTitle').value

        // logoUrl
        const logoUrl = document.getElementById('logoUrl').value

        const uiConfig = {
          accent: ac
        }

        if (title) {
          uiConfig.title = title
        }
        if (subTitle) {
          uiConfig.subTitle = subTitle
        }
        if (logoUrl) {
          uiConfig.logoUrl = logoUrl
        }

        document.getElementById('render-options').innerText = JSON.stringify(
          { theme, uiConfig },
          null,
          2
        )

        return {
          theme: theme,
          uiConfig: uiConfig
        }
      }

      window.connectMetaMaskWallet = async function (provider, walletType) {
        if (isConnectingWallet) {
          return
        }
        if (typeof provider === undefined) {
          alert(`${walletType} is unintalled`)
          return
        }
        if (isTrollboxReady) {
          clearEvents()
          ChatboxSDK.processWallet({
            isWalletConnected: true,
            provider
          })
        }
        const connect = async () => {
          try {
            const accounts = await provider
              .request({ method: 'eth_requestAccounts' })
              .catch(() => {
                reject({
                  name: 'MetaMaskConnectFailed'
                })
                console.info('üöÄ ~ connect ~ MetaMaskConnectFailed:')
              })
            const rawAccount = accounts[0]

            if (!rawAccount) {
              throw new Error()
            }

            // Uniformly convert EVM addresses to lowercase
            // const account = rawAccount.toLowerCase()
            const account = rawAccount

            if (!isTrollboxReady) {
              console.log('üöÄ ~ connect ~ provider:', provider)
              console.log('üöÄ ~ connect ~ window.provider:', window.provider)
              const { theme, uiConfig } = generateRenderOptions()

              ChatboxSDK.loadChatbox({
                isWalletConnected: true,
                // provider: window.provider,
                provider: provider,
                theme,
                uiConfig
              })
            }

            if (isTrollboxReady) {
              ChatboxSDK.processAccount({
                account: account
              })
            }

            walletInfo = {
              // type: 'metamask',
              type: walletType,
              address: account
            }

            showWallInfo(walletInfo)

            isConnectingWallet = false

            provider.on('accountsChanged', onMetaMaskAccountsChanged)
          } catch (err) {
            console.info('üöÄ ~ connect ~ err:', err)
            console.log(err)
          }
        }
        connect()
      }

      window.connectTPWallet = async function () {
        if (isConnectingWallet) {
          return
        }
        // if (walletInfo?.type === 'tanglepay') {
        //   alert('TanglePay wallet has already been connected.')
        //   return
        // }
        if (walletInfo?.type === 'metamask' && isTrollboxReady) {
          clearEvents()
          ChatboxSDK.dispatchWalletUpdate({
            walletType: 1
          })
        }
        isConnectingWallet = true
        // Ensure iota is ready
        if (iota.isTanglePay && iota.tanglePayVersion !== '') {
          try {
            const res = await iota.request({
              method: 'iota_connect',
              params: {
                // expires: 3000000
              }
            })

            iota._events.on(iotaEventKey, onTPAccountsChanged)

            if (!walletInfo) {
              const { theme, uiConfig } = generateRenderOptions()
              ChatboxSDK.loadChatbox({
                isWalletConnected: true,
                provider: {
                  isTanglePay: true,
                  isGroupfiNative: true
                },
                theme,
                uiConfig
              })
            }

            walletInfo = {
              type: 'tanglepay',
              address: res.address
            }

            showWallInfo(walletInfo)
          } catch (error) {
            console.log('connectWallet error:', error)
          }
        } else {
          alert('Please install Tanglepay first.')
        }
        isConnectingWallet = false
      }

      window.onload = function () {
        const MMSDK = new MetaMaskSDK.MetaMaskSDK({
          dappMetadata: {
            name: 'Example Pure JS Dapp',
            url: window.location.href
          },
          extensionOnly: true
          // Other options.
        })

        setTimeout(() => {
          const provider = MMSDK.getProvider()
          // ChatboxSDK.setWalletProvider(provider);
          window.metamaskProvider = provider
        }, 0)

        renderGroups()
        renderThemes()
        renderAccentColors()
      }

      window.removeChatbox = function () {
        try {
          clearEvents()

          showWallInfo(null)
          ChatboxSDK.removeChatbox()

          isTrollboxReady = false
        } catch (error) {
          console.error('Error removing iframe:', error)
        }
      }

      // window.linkTo = () => {
      //   window.open(window.location.href.replace('index.html', 'auto.html'))
      // }

      // GTest start
      const api = `https://api.groupfi.ai`
      const tokenAddress = '0x30d2422A2cD8471e19867Bc41E76AeF6e0044A30'
      const get = async (url) => {
        const response = await fetch(`${api}/${url}`, {
          headers: {
            'Content-Type': 'application/json'
          }
        })
        return response.json()
      }
      const checkAddressGetStatus = async (type = 2) => {
        if (window.provider && walletInfo?.address) {
          const chainId = await window.provider.request({
            method: 'eth_chainId'
          })
          if (chainId == 148) {
            if (!window.tokenContract) {
              const web3 = new window.Web3(window.provider)
              const tokenContract = new web3.eth.Contract(
                window.TokenERC20,
                tokenAddress
              )
              window.tokenContract = tokenContract
            }
            try {
              const balance = await window.tokenContract.methods
                .balanceOf(walletInfo?.address)
                .call()
              console.log('üöÄ ~ checkAddressGetStatus ~ balance:', balance)
              if (parseFloat(balance) > 0) {
                return false
              }
            } catch (error) {}
            return true
          }
        }
        return true
      }
      const loopCheckAddress = () => {
        if (window.timeHandler) {
          clearInterval(window.timeHandler)
        }
        window.timeHandler = setInterval(async () => {
          const bool = await checkAddressGetStatus()
          if (!bool) {
            clearInterval(window.timeHandler)
            window.timeHandler = null
            ChatboxSDK.request({
              method: 'addAccountToGroupByGroupId',
              params: {
                groupId: `groupfiGFTEST1crab4f3b6b3e0255296261d05bbca9805e6efeaef26f593b98472a29cc69a90bde26`
              }
            })
          }
        }, 3000)
      }
      window.getGTest = async () => {
        if (window.provider) {
          const chainId = await window.provider.request({
            method: 'eth_chainId'
          })
          loopCheckAddress()
          const res = await get(
            `faucet?chainid=${parseInt(chainId)}&token=${tokenAddress}&to=${
              walletInfo?.address
            }&amount=11`
          )
          document.getElementById('result').innerText = JSON.stringify(res)
          // loopCheckAddress()
        } else {
          document.getElementById('result').innerText =
            'please connect wallet first'
        }
      }
      // GTest end

      window.nextLink = () => {
        window.location.hash = `hast${parseInt(Math.random() * 1000)}`
        recommentGroups()
      }

      const groupList = [
        {
          text: `test-Groupfi's test NFT group`,
          value: `groupfiGroupfi'stestnftgroup44fcab69fde4de3106429cefd94372252c2b82a4808b0879c0308600530b1694`
        },
        {
          text: 'test-GFTEST1 fish',
          value:
            'groupfiGFTEST1fish0de70cefe0daf1ee0d431359a9c794a621c2d0a6a419f0726317d81e50557d24'
        },
        {
          text: 'test-Groupfi Test NFT2',
          value:
            'groupfiGroupfiTestNFT2f7d754d6f9bd676435581567aa9ecc5d1bf402ada735192d111f15cb6e1e1751'
        },
        {
          text: 'GFTEST1 crab',
          value:
            'groupfiGFTEST1craba85d013a1c265d0337fbbfd433da5614ecc8116d95ed2131614c5e591a517f7f'
        },
        {
          text: 'TOKEN fish',
          value:
            'groupfiTOKENfish19a2a0bef1ebc649ac5c25c09f693909d2c9fd269e7b96ec2d9c3fffd4de701a'
        },
        {
          text: 'SOL crab',
          value:
            'groupfiSOLcrab0c44862d3aa0a7040a8a36d1fdfb16a62461183876ae39c278dd5dfabd4055c0'
        },
        {
          text: 'SOLANA1 crab',
          value:
            'groupfiSOLANA1crab24c2212ac62d865f937921070d7002113aed01d3271759339639bc0a1ed2518a'
        },
        {
          text: 'Honeyland Generations Bees',
          value:
            'groupfiHoneylandGenerationsBees1065cc7c14ce965e47bde5502fd96dfd7642315c44a04f91d35394c43ae1a49d'
        },
        {
          text: 'Etherlink crab',
          value:
            'groupfiEtherlinkcrab4ba35b134bc2d4396f2b92e67b8fe6de1ca8b598ef820c7f5b4d3e03b672cfd8'
        },
        {
          text: 'LuksoGroupfiTestV10',
          value:
            'groupfiLuksoGroupfiTestV107587c92c7d5d26671e3f6fcb78be8659939c6dd78c5aeeb8cfac6699c144f3d9'
        },
        {
          text: 'Stakingverse Appreciation NFT',
          value:
            'groupfiStakingverseAppreciationNFTc48fcc996ad2a9d28824f0b57c8f3b6128ac174539924565f93ecd79d17f6a8c'
        },
        {
          text: 'CrossT fish',
          value:
            'groupfiCrossTfish4cd2bb9b39d5af472768e9c782f6b303e7fa064370af3bb3fd1a342ee908c55f'
        },
        {
          text: 'Cross Chain Test NFT',
          value:
            'groupfiCrossChainTestNFT2900c6bdd61679a64b4321fc4d2eebd198bde9e8950bea9500a3a47cb5bf7803'
        },
        {
          text: 'ceshi11',
          value:
            'groupfiCrossTfish989ed53f0f9a64809011f4afd8895fff4ba49fa22ce0f4f64771a9067c7be1d8'
        },
        {
          text: 'TEST AMOY NFT',
          value:
            'groupfiTESTAMOYNFT1f3d416de26b0e4958302a205290289cf2449d17264216c208b6e3718e797933'
        },

        // for test token icon
        {
          text: 'PEPE crab',
          value:
            'groupfiPEPEcrab8de932874b256a82c48b0c58edba2a5ebc65dd6465ffbe9d05be4f9149ea51a1'
        },
        {
          text: 'Mango market',
          value:
            'groupfiMangomarket3ba1189e8413950a81f81f1086c857de5b477a8f3e9c8b4648a914c61a6cc6c5'
        },
        {
          text: 'TUSD crab',
          value:
            'groupfiTUSDcrab974879dccd8adfb689b7e5a7faecc5b1641b6022596e9e20bfe7ae1e17f1b805'
        },
        {
          text: 'LSP8 NFT',
          value:
            'groupfiLSP8NFTea29b066c6f3d391067fbb788a6d0b012f990bc49ab4242593994162268f9475'
        },
        {
          text: 'LSP7Test crab',
          value:
            'groupfiLSP7Testcrab4ea99ce9a9ec12d4849420d663f6149a47903e7494605e34cd483573cf6818c6'
        },
        { text: 'soon-whale', value: 'soon-whale' },
        { text: 'soon', value: 'soon' },
        { text: 'smr-whale', value: 'smr-whale' },
        { text: 'smr', value: 'smr' },
        { text: 'staff-marketing', value: 'staff-marketing' },
        { text: 'staff-developer', value: 'staff-developer' },
        { text: 'dapper-groupfi', value: 'dapper-groupfi' },
        { text: 'GroupFi Announcement', value: 'GroupFi Announcement' },
        { text: 'alpha-test', value: 'alpha-test' },
        { text: 'iceberg-1', value: 'iceberg-1' },
        { text: 'iceberg-2', value: 'iceberg-2' },
        { text: 'iceberg-3', value: 'iceberg-3' },
        { text: 'iceberg-4', value: 'iceberg-4' },
        { text: 'iceberg-5', value: 'iceberg-5' },
        { text: 'iceberg-6', value: 'iceberg-6' },
        { text: 'iceberg-7', value: 'iceberg-7' },
        { text: 'iceberg-8', value: 'iceberg-8' },
        { text: 'iceberg-9', value: 'iceberg-9' }
      ]

      function renderGroups() {
        const container = document.getElementById('smr-groups')
        container.innerHTML = ''

        groupList.forEach(({ text, value }, index) => {
          const br = document.createElement('br')
          // const form = document.createElement('form');
          const input = document.createElement('input')
          input.type = 'checkbox'
          input.name = 'smr-group'
          input.value = value
          input.id = `check${index}` // ‰∏∫ÊØè‰∏™ input ËÆæÁΩÆ‰∫ÜÂîØ‰∏ÄÁöÑ id
          input.style.marginRight = '1rem'
          const input1 = document.createElement('input')
          input1.type = 'radio'
          input1.name = 'smr-group'
          input1.value = value
          input1.id = `radio${index}` // ‰∏∫ÊØè‰∏™ input ËÆæÁΩÆ‰∫ÜÂîØ‰∏ÄÁöÑ id
          input1.style.marginRight = '1rem'
          const label = document.createElement('label') // ÂàõÂª∫ label ÂÖÉÁ¥†
          label.setAttribute('for', input.id) // ËÆæÁΩÆ label ÁöÑ for Â±ûÊÄß
          label.textContent = text // Â∞ÜÂêçÂ≠ó‰Ωú‰∏∫ label ÁöÑÊñáÊú¨ÂÜÖÂÆπ

          container.appendChild(input) // Â∞Ü input Ê∑ªÂä†Âà∞ form ‰∏≠
          container.appendChild(input1) // Â∞Ü input Ê∑ªÂä†Âà∞ form ‰∏≠
          container.appendChild(label) // Ê∑ªÂä† label Âà∞ form
          container.appendChild(br)
        })
      }

      function renderEVMGroups() {
        const container = document.getElementById('evm-groups')
        ;['First EVM group'].forEach((name, index) => {
          const br = document.createElement('br')
          const input = document.createElement('input')
          input.type = 'checkbox'
          input.id = `check${index}` // ‰∏∫ÊØè‰∏™ input ËÆæÁΩÆ‰∫ÜÂîØ‰∏ÄÁöÑ id
          input.value = name
          input.name = 'evm-group'
          const label = document.createElement('label') // ÂàõÂª∫ label ÂÖÉÁ¥†
          label.setAttribute('for', input.id) // ËÆæÁΩÆ label ÁöÑ for Â±ûÊÄß
          label.textContent = name // Â∞ÜÂêçÂ≠ó‰Ωú‰∏∫ label ÁöÑÊñáÊú¨ÂÜÖÂÆπ

          container.appendChild(input) // Â∞Ü input Ê∑ªÂä†Âà∞ form ‰∏≠
          container.appendChild(label) // Ê∑ªÂä† label Âà∞ form
          container.appendChild(br) // Â∞Ü form Ê∑ªÂä†Âà∞ container ‰∏≠
        })
      }

      window.recommentGroups = async () => {
        if (!isTrollboxReady) {
          alert('Trollbox is not ready')
          return
        }
        const form = document.getElementById('smr-groups')
        const checkboxes = form.querySelectorAll(
          'input[type=checkbox][name=smr-group]:checked'
        )
        const radios = form.querySelectorAll(
          'input[type=radio][name=smr-group]:checked'
        )

        const selectedGroups = Array.from(checkboxes).map(
          (checkbox) => checkbox.value
        )

        const announcementGroups = Array.from(radios).map(
          (radio) => radio.value
        )
        const includes = selectedGroups.map((groupId) => ({
          groupId
        }))
        const announcement = announcementGroups.map((groupId) => ({
          groupId
        }))
        ChatboxSDK.request({
          method: 'setGroups',
          params: {
            includes: includes,
            announcement: announcement
          }
        })
      }

      window.removeChatbox = () => {
        ChatboxSDK.removeChatbox()
      }

      window.renderThemes = async () => {
        const container = document.getElementById('themes')
        const themes = ['light', 'dark']
        themes.forEach((name, index) => {
          const input = document.createElement('input')
          input.type = 'radio'
          input.id = `theme${index}` // ‰∏∫ÊØè‰∏™ input ËÆæÁΩÆ‰∫ÜÂîØ‰∏ÄÁöÑ id
          input.value = name
          input.name = 'theme'
          input.checked = index === 0
          const label = document.createElement('label') // ÂàõÂª∫ label ÂÖÉÁ¥†
          label.setAttribute('for', input.id) // ËÆæÁΩÆ label ÁöÑ for Â±ûÊÄß
          label.textContent = name // Â∞ÜÂêçÂ≠ó‰Ωú‰∏∫ label ÁöÑÊñáÊú¨ÂÜÖÂÆπ
          container.appendChild(input)
          container.appendChild(label) // Ê∑ªÂä† label Âà∞ form
        })
      }

      window.renderAccentColors = async () => {
        const container = document.getElementById('accent_colors')
        const themes = [
          'violet',
          'blue',
          'red',
          'orange',
          'yellow',
          'amber',
          'grey'
        ]
        themes.forEach((name, index) => {
          const input = document.createElement('input')
          input.type = 'radio'
          input.id = `ac${index}` // ‰∏∫ÊØè‰∏™ input ËÆæÁΩÆ‰∫ÜÂîØ‰∏ÄÁöÑ id
          input.value = name
          input.name = 'ac'
          input.checked = index === 0
          const label = document.createElement('label') // ÂàõÂª∫ label ÂÖÉÁ¥†
          label.setAttribute('for', input.id) // ËÆæÁΩÆ label ÁöÑ for Â±ûÊÄß
          label.textContent = name // Â∞ÜÂêçÂ≠ó‰Ωú‰∏∫ label ÁöÑÊñáÊú¨ÂÜÖÂÆπ
          container.appendChild(input)
          container.appendChild(label) // Ê∑ªÂä† label Âà∞ form
        })
      }
      window.addTestGroup = () => {
        const groupName = document.getElementById('group-name').value
        const groupId = document.getElementById('group-id').value
        groupList.unshift({
          text: groupName,
          value: groupId
        })
        renderGroups()
      }
    </script>

    <h1 style="margin: 10px 0px">Test GroupFi Trollbox Iframe</h1>
    <div>
      <button
        type="button"
        class="btn btn-primary mr-4"
        onclick="connectTPWallet()"
      >
        Use TanglePay Wallet
      </button>

      <button
        type="button"
        class="btn btn-primary mr-4"
        onclick="connectMetaMaskWallet(window.metamaskProvider, 'metamask')"
      >
        Use MetaMask Wallet
      </button>

      <button
        type="button"
        class="btn btn-primary mr-4"
        onclick="connectMetaMaskWallet(window.okxwallet, 'okx')"
      >
        Use OKX Wallet
      </button>

      <button
        type="button"
        class="btn btn-primary mr-4"
        onclick="connectSolanaWallet(window.phantom?.solana, 'Phantom')"
      >
        Use Phantom Wallet
      </button>

      <button
        type="button"
        class="btn btn-primary mr-4"
        onclick="connectMetaMaskWallet(window.lukso, 'Universal Profile')"
      >
        Use Universal Profile Wallet
      </button>

      <button
        type="button"
        class="btn btn-primary mr-4"
        onclick="startBrowseMode()"
      >
        Browse Mode
      </button>

      <button
        type="button"
        class="btn btn-primary mr-4"
        onclick="removeChatbox()"
      >
        Remove Trollbox
      </button>

      <!-- <button type="button" class="btn btn-primary" onclick="removeChatbox()">
        Disconnect Wallet
      </button> -->
      <!-- <button type="button" class="btn btn-primary mr-4" onclick="linkTo()">
        Link To
      </button> -->
      <button type="button" class="btn btn-primary mr-4" onclick="getGTest()">
        Get GTest
      </button>
      <button type="button" class="btn btn-primary mr-4" onclick="nextLink()">
        Next Page
      </button>
    </div>

    <div class="mt-2 mb-1">Èí±ÂåÖÁ±ªÂûãÔºö<span id="type"></span></div>
    <div>Èí±ÂåÖÂú∞ÂùÄ: <span id="address"></span></div>
    <div>ËØ∑Ê±ÇÁªìÊûú: <span id="result"></span></div>

    <div class="mt-3">Is Trollbox Ready ? <span id="ready">false</span></div>

    <div class="d-flex">
      <div class="d-inline-block w-[60%]">
        <div class="mt-2 block w-[300px] max-w-[90vw]">
          <form id="themes">
            <label>Theme: </label>
          </form>
        </div>
        <div class="mt-2 block w-[600px] max-w-[90vw]">
          <form id="accent_colors">
            <label>Accent color:</label>
          </form>
        </div>
        <div class="mt-1">
          <form>
            <label>Title: </label>
            <input
              type="text"
              class="form-control d-inline-block w-[500px]"
              id="title"
              placeholder="Title"
            />
          </form>
        </div>
        <div class="mt-1">
          <form>
            <label>subTitle: </label>
            <input
              type="text"
              class="form-control d-inline-block w-[500px]"
              id="subTitle"
              placeholder="subTitle"
            />
          </form>
        </div>
        <div class="mt-1">
          <form>
            <label>LogoUrl: </label>
            <input
              type="text"
              class="form-control d-inline-block w-[500px]"
              id="logoUrl"
              placeholder="logo url"
            />
          </form>
        </div>
        <div>
          <button
            type="button"
            class="btn btn-primary"
            onclick="generateRenderOptions()"
          >
            test render options
          </button>
        </div>
      </div>
      <div
        class="d-inline-block w-[25%] h-[220px] border"
        id="render-options"
      ></div>
    </div>

    <div class="mt-5">
      <button type="button" class="btn btn-primary" onclick="addTestGroup()">
        add test group
      </button>
      <input
        type="text"
        class="form-control d-inline-block w-[200px]"
        id="group-name"
        placeholder="group name"
      />
      <input
        type="text"
        class="form-control d-inline-block w-[600px]"
        id="group-id"
        placeholder="dapp group id"
      />
    </div>
    <div class="mt-2 block w-[300px] max-w-[90vw]">
      <button type="button" class="btn btn-primary" onclick="recommentGroups()">
        Recommend groups for users
      </button>
      <form id="smr-groups"></form>
    </div>
    <script src="./src/abi/TokenERC20.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
  </body>
</html>
