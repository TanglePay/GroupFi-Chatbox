<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Trollbox SDK Demo</title>
    <!-- <link
      rel="stylesheet"
      href="https://unpkg.com/groupfi-trollbox-sdk@1.0.14/dist/iife/assets/style.css"
    /> -->
    <link rel="stylesheet" href="./dist/iife/assets/style.css" />
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
      crossorigin="anonymous"
    />

    <script src="./demo_assets/third-party/tanglepay-sdk/tanglepay-common.js"></script>
    <script src="./demo_assets/third-party/tanglepay-sdk/index.js"></script>
    <!-- <script src="https://unpkg.com/groupfi-trollbox-sdk@1.0.14/dist/iife/index.js"></script> -->
    <script src="./dist/iife/index.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
      crossorigin="anonymous"
    ></script>
    <script defer src="https://c0f4f41c-2f55-4863-921b-sdk-docs.github.io/cdn/metamask-sdk.js"></script>
    <style>
      .hidden {
        display: none;
      }
      body {
        padding-left: 10px;
      }
    </style>
  </head>
  <body>
    <script>
      let isTrollboxReady = false;

      // const MMSDK = new MetaMaskSDK.MetaMaskSDK({
      //   dappMetadata: {
      //     name: 'Example Pure JS Dapp',
      //     url: window.location.href,
      //   },
      //   extensionOnly: true,
      //   // Other options.
      // });

      // setTimeout(() => {
      //   const provider = MMSDK.getProvider();
      //   trollbox.setWalletProvider(provider);
      //   window.provider = provider;
      // }, 0);

      window.addEventListener('trollbox-ready', function () {
        isTrollboxReady = true;
        document.getElementById('ready').innerText = true;

        if (walletInfo && walletInfo.type === 'metamask') {
          trollbox.dispatchMetaMaskAccountChanged({
            account: walletInfo.address,
          });
        }
      });

      const storageKey = 'groupfi-wallet-info';

      function storeWalletInfo(walletInfo) {
        // localStorage.setItem(storageKey, JSON.stringify(walletInfo));
      }

      function clearWalletInfo() {
        localStorage.removeItem(storageKey);
      }

      function getWalletInfoFromStorage() {
        const walletInfoStr = window.localStorage.getItem(storageKey);
        if (walletInfoStr) {
          return JSON.parse(walletInfoStr);
        }
        return null;
      }

      let walletInfo = getWalletInfoFromStorage();

      window.onTPAccountsChanged = (data) => {
        const newAddress = data.address;
        if (walletInfo && walletInfo.address === newAddress) {
          return;
        }
        walletInfo = {
          type: 'tanglepay',
          address: newAddress,
        };
        showWallInfo(walletInfo);
      };

      function showWallInfo(info) {
        const typeDom = document.getElementById('type');
        const addressDom = document.getElementById('address');

        typeDom.innerText = info?.type ?? '';
        addressDom.innerText = info?.address ?? '';

        if (info) {
          storeWalletInfo(info);
        } else {
          clearWalletInfo();
        }
      }

      const iotaEventKey = 'iota_event_accountsChanged';

      let isConnectingWallet = false;

      function onMetaMaskAccountsChanged(accounts) {
        console.log('dapp metamask acounts changes', accounts);
        const account = accounts[0];

        walletInfo = {
          type: 'metamask',
          address: account,
        };

        showWallInfo(walletInfo);

        if (isTrollboxReady) {
          trollbox.dispatchMetaMaskAccountChanged({
            account: account,
          });
        }
      }

      function clearEvents() {
        iota._events.removeAllListeners(iotaEventKey);
        // window.ethereum.removeAllListeners();
        window.provider.removeAllListeners();
      }

      window.startBrowseMode = () => {
        const form = document.getElementById('themes');
        const themes = form.querySelectorAll('input[type=radio][name=theme]:checked');
        const theme = themes[0].value;
        trollbox.loadTrollbox({ theme: theme })
      }

      window.connectMetaMaskWallet = async function () {
        if (isConnectingWallet) {
          return;
        }
        if (walletInfo?.type === 'metamask') {
          alert('MetaMask wallet has already been connected.');
          return;
        }
        // if (typeof window.ethereum === undefined) {
        //   alert('MetaMask is unintalled');
        //   return;
        // }
        if (typeof window.provider === undefined) {
          alert('MetaMask is unintalled');
          return;
        }
        if (walletInfo?.type && isTrollboxReady) {
          clearEvents();
          trollbox.dispatchWalletUpdate({
            walletType: 2,
          });
        }
        const connect = async () => {
          try {
            // const accounts = await window.ethereum
            //   .request({ method: 'eth_requestAccounts' })
            //   .catch(() => {
            //     reject({
            //       name: 'MetaMaskConnectFailed',
            //     });
            //   });
            const accounts = await window.provider
              .request({ method: 'eth_requestAccounts' })
              .catch(() => {
                reject({
                  name: 'MetaMaskConnectFailed',
                });
              });
            console.log('===> metamask connect accounts', accounts);
            const rawAccount = accounts[0];

            if (!rawAccount) {
              throw new Error();
            }

            // Uniformly convert EVM addresses to lowercase
            const account = rawAccount.toLowerCase();

            if (!walletInfo) {
              const form = document.getElementById('themes');
              const themes = form.querySelectorAll('input[type=radio][name=theme]:checked');
              const theme = themes[0].value;
              trollbox.loadTrollbox({ walletType: 'metamask', theme: theme });
            }

            if (isTrollboxReady) {
              trollbox.dispatchMetaMaskAccountChanged({
                account: account,
              });
            }

            walletInfo = {
              type: 'metamask',
              address: account,
            };

            showWallInfo(walletInfo);

            isConnectingWallet = false;

            // window.ethereum.on('accountsChanged', onMetaMaskAccountsChanged);
            window.provider.on('accountsChanged', onMetaMaskAccountsChanged);
          } catch (err) {
            console.log(err);
          }
        };
        connect();
      };

      window.connectTPWallet = async function () {
        if (isConnectingWallet) {
          return;
        }
        if (walletInfo?.type === 'tanglepay') {
          alert('TanglePay wallet has already been connected.');
          return;
        }
        if (walletInfo?.type === 'metamask' && isTrollboxReady) {
          clearEvents();
          trollbox.dispatchWalletUpdate({
            walletType: 1,
          });
        }
        isConnectingWallet = true;
        // Ensure iota is ready
        if (iota.isTanglePay && iota.tanglePayVersion !== '') {
          try {
            const res = await iota.request({
              method: 'iota_connect',
              params: {
                // expires: 3000000
              },
            });

            iota._events.on(iotaEventKey, onTPAccountsChanged);

            if (!walletInfo) {
              const form = document.getElementById('themes');
              const themes = form.querySelectorAll('input[type=radio][name=theme]:checked');
              const theme = themes[0].value;
              trollbox.loadTrollbox({ walletType: 'tanglepay', theme: theme });
            }

            walletInfo = {
              type: 'tanglepay',
              address: res.address,
            };

            showWallInfo(walletInfo);
          } catch (error) {
            console.log('connectWallet error:', error);
          }
        } else {
          alert('Please install Tanglepay first.');
        }
        isConnectingWallet = false;
      };

      window.onload = function () {
        const MMSDK = new MetaMaskSDK.MetaMaskSDK({
          dappMetadata: {
            name: 'Example Pure JS Dapp',
            url: window.location.href,
          },
          extensionOnly: true,
          // Other options.
        });

        setTimeout(() => {
          const provider = MMSDK.getProvider();
          trollbox.setWalletProvider(provider);
          window.provider = provider;
        }, 0);

        renderGroups();
        renderThemes();
      };

      window.removeTrollbox = function () {
        try {
          clearEvents();

          showWallInfo(null);
          trollbox.removeTrollbox();
        } catch (error) {
          console.error('Error removing iframe:', error);
        }
      };

      function renderGroups() {
        const container = document.getElementById('smr-groups');

        [
          'EtherVisions[148]',
          'CryptoCatalyst[148]',
          'First EVM group[148]',
          'Second EVM group[148]',
          'soon-whale',
          'soon',
          'smr-whale',
          'smr',
          'staff-marketing',
          'staff-developer',
          'dapper-groupfi',
          'GroupFi Announcement',
          'alpha-test',
          'iceberg-1',
          'iceberg-2',
          'iceberg-3',
          'iceberg-4',
          'iceberg-5',
          'iceberg-6',
          'iceberg-7',
          'iceberg-8',
          'iceberg-9',
        ].forEach((name, index) => {
          const br = document.createElement('br');
          // const form = document.createElement('form');
          const input = document.createElement('input');
          input.type = 'checkbox';
          input.name = 'smr-group';
          input.value = name;
          input.id = `check${index}`; // 为每个 input 设置了唯一的 id
          input.style.marginRight = '1rem';
          const input1 = document.createElement('input');
          input1.type = 'radio';
          input1.name = 'smr-group';
          input1.value = name;
          input1.id = `radio${index}`; // 为每个 input 设置了唯一的 id
          input1.style.marginRight = '1rem'
          const label = document.createElement('label'); // 创建 label 元素
          label.setAttribute('for', input.id); // 设置 label 的 for 属性
          label.textContent = name; // 将名字作为 label 的文本内容

          container.appendChild(input); // 将 input 添加到 form 中
          container.appendChild(input1); // 将 input 添加到 form 中
          container.appendChild(label); // 添加 label 到 form
          container.appendChild(br);
        });
      }

      function renderEVMGroups() {
        const container = document.getElementById('evm-groups');
        ['First EVM group'].forEach((name, index) => {
          const br = document.createElement('br');
          const input = document.createElement('input');
          input.type = 'checkbox';
          input.id = `check${index}`; // 为每个 input 设置了唯一的 id
          input.value = name;
          input.name = 'evm-group';
          const label = document.createElement('label'); // 创建 label 元素
          label.setAttribute('for', input.id); // 设置 label 的 for 属性
          label.textContent = name; // 将名字作为 label 的文本内容

          container.appendChild(input); // 将 input 添加到 form 中
          container.appendChild(label); // 添加 label 到 form
          container.appendChild(br); // 将 form 添加到 container 中
        });
      }

      window.recommentGroups = async () => {
        if (!isTrollboxReady) {
          alert('Trollbox is not ready');
        }
        const form = document.getElementById('smr-groups');
        const checkboxes = form.querySelectorAll(
          'input[type=checkbox][name=smr-group]:checked'
        );
        const radios = form.querySelectorAll(
          'input[type=radio][name=smr-group]:checked'
        );

        const selectedGroups = Array.from(checkboxes).map(
          (checkbox) => checkbox.value
        );
        const announcementGroups = Array.from(radios).map((radio) => radio.value);

        const includes = selectedGroups.map((group) => {
          const splits = group.split('[');
          if (splits.length === 1) {
            return {
              groupName: splits[0],
            };
          }
          const chainId = parseInt(splits[1]);
          return {
            groupName: splits[0],
            chainId,
          };
        });

        const announcement = announcementGroups.map((group) => {
          const splits = group.split('[');
          if (splits.length === 1) {
            return {
              groupName: splits[0],
            };
          }
          const chainId = parseInt(splits[1]);
          return {
            groupName: splits[0],
            chainId,
          };
        });

        trollbox.request({
          method: 'setForMeGroups',
          params: {
            includes: includes,
            announcement: announcement
          },
        });
      };

      window.removeTrollbox = () => {
        trollbox.removeTrollbox()
      }

      window.renderThemes = async () => {
        const container = document.getElementById('themes');
        const themes = ['light', 'dark'];
        themes.forEach((name, index) => {
          const input = document.createElement('input');
          input.type = 'radio';
          input.id = `theme${index}`; // 为每个 input 设置了唯一的 id
          input.value = name;
          input.name = 'theme';
          input.checked = index === 0;
          const label = document.createElement('label'); // 创建 label 元素
          label.setAttribute('for', input.id); // 设置 label 的 for 属性
          label.textContent = name; // 将名字作为 label 的文本内容
          container.appendChild(input);
          container.appendChild(label); // 添加 label 到 form
        });
      };
    </script>

    <h1 style="margin: 10px 0px">Test GroupFi Trollbox Iframe</h1>

    <div>
      <button
        type="button"
        class="btn btn-primary mr-4"
        onclick="connectTPWallet()"
      >
        Use TanglePay Wallet
      </button>

      <button
        type="button"
        class="btn btn-primary mr-4"
        onclick="connectMetaMaskWallet()"
      >
        Use MetaMask Wallet
      </button>

      <button
        type="button"
        class="btn btn-primary mr-4"
        onclick="startBrowseMode()"
      >
        Browse Mode
      </button>

      <button
        type="button"
        class="btn btn-primary mr-4"
        onclick="removeTrollbox()"
      >
        Remove Trollbox
      </button>

      <!-- <button type="button" class="btn btn-primary" onclick="removeTrollbox()">
        Disconnect Wallet
      </button> -->
    </div>

    <div class="mt-2 mb-1">钱包类型：<span id="type"></span></div>
    <div>钱包地址: <span id="address"></span></div>

    <div class="mt-5">Is Trollbox Ready ? <span id="ready">false</span></div>
    <div class="mt-2 block w-[300px]">
      <form id="themes"></form>
    </div>
    <div class="mt-2 block w-[300px]">
      <button type="button" class="btn btn-primary" onclick="recommentGroups()">
        Recommend groups for users
      </button>
      <form id="smr-groups"></form>
    </div>1000000
  </body>
</html>
